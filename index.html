<p><strong>The same designs make using SystemVerilog VHDL and Verilog</strong></p>
<p>Every design contains top module + 3&nbsp;modules that have the same functionality but written on&nbsp;SystemVerilog, VHDL, and Verilog:</p>
<ul style="list-style-type: disc;">
<li>VHDL top Entity that contains 3&nbsp;component</li>
<li>SystemVerilog&nbsp;component</li>
<li>Verilog&nbsp;component</li>
<li>VHDL&nbsp;component</li>
</ul>
<p>The simulation was written on SystemVerilog. Some simulation projects contain external stimulus files and files with expected simulation results.&nbsp;&nbsp;</p>
<p>In additionals presents&nbsp;</p>
<ul style="list-style-type: disc;">
<li>RTL schematics</li>
<li>Synthesis schematics</li>
<li>Implementation schematics</li>
<li>Simulations waveforms</li>
</ul>
<p>All projects are available in&nbsp;<a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog">https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog</a></p>
<p>The projects made in&nbsp;Vivado v2019.1.1 (64-bit)</p>
<p>The unexpected results of RTL, Synthesis, Implementation, or Simulations marked by Orange <span style="color: #ff6600;">color</span>.</p>
<p>&nbsp;</p>
<table style="width: 1540px; border-color: black; float: left;" border="3" cellspacing="10">
<tbody>
<tr>
<td style="width: 300px;"><strong>Description</strong></td>
<td style="width: 380px;"><strong>System Verilog</strong></td>
<td style="width: 380px;"><strong>Verilog</strong></td>
<td style="width: 380px;"><strong>VHDL</strong></td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.1 COMBINATIONAL LOGIC</p>
<p>HDL Example 4.1 illustrates behavioral descriptions of a module that computes the Boolean function<br />y = ~a &amp; ~b &amp; ~c | a &amp; ~b &amp; ~c | a &amp; ~b &amp; c<br />~ - not<br />&amp; - and<br />| - or</p>
<ul>
<li><a href="HDL%20Example 4.1 COMBINATIONAL LOGIC\HDL Example 4.1 COMBINATIONAL LOGIC RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li>Implementation schematics</li>
<li><a href="HDL%20Example 4.1 COMBINATIONAL LOGIC\HDL Example 4.1 COMBINATIONAL LOGIC Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.1%20COMBINATIONAL%20LOGIC" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">module sillyfunction_sv<br />(<br /> input logic a, b, c, <br /> output logic y<br />);<br /> assign y = ~a &amp; ~b &amp; ~c |<br /> a &amp; ~b &amp; ~c |<br /> a &amp; ~b &amp; c;<br />endmodule</td>
<td style="width: 380px;">module sillyfunction_v <br />(<br /> input a, b, c,<br /> output y<br />);<br /> assign y = ~a &amp; ~b &amp; ~c |<br /> a &amp; ~b &amp; ~c |<br /> a &amp; ~b &amp; c;<br />endmodule</td>
<td style="width: 380px;">&nbsp;library IEEE; use IEEE.STD_LOGIC_1164.all;
<p>entity sillyfunction_vhd is</p>
<p>port<br />(<br /> a, b, c: in STD_LOGIC;<br /> y: out STD_LOGIC<br />);<br />end;</p>
<p>architecture synth of sillyfunction_vhd is<br />begin<br /> y &lt;= (not a and not b and not c) or<br /> (a and not b and not c) or<br /> (a and not b and c);<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.2 INVERTERS</p>
<p>HDL Example 4.2 describes four inverters<br />connected to 4-bit busses.&nbsp;Bitwise operators</p>
<ul>
<li><a href="HDL Example 4.2 INVERTERS\HDL Example 4.2 INVERTERS RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li>Implementation schematics</li>
<li><a href="HDL Example 4.2 INVERTERS\HDL Example 4.2 INVERTERS Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.2%20INVERTERS" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">
<p>module inv_sv<br />(<br /> input logic [3:0] a,<br /> output logic [3:0] y<br />);</p>
<p>assign y = ~a;</p>
<p>endmodule</p>
&nbsp;</td>
<td style="width: 380px;">&nbsp;module inv_v
<p>(<br /> input [3:0] a,<br /> output [3:0] y<br />);</p>
<p>assign y = ~a;</p>
<p>endmodule</p>
</td>
<td style="width: 380px;">&nbsp;library IEEE; use IEEE.STD_LOGIC_1164.all;
<p>entity inv_vhd is<br />port<br />(<br /> a: in STD_LOGIC_VECTOR(3 downto 0);<br /> y: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p>architecture synth of inv_vhd is<br /> begin<br /> y &lt;= not a;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">&nbsp;
<p>&nbsp;HDL Example 4.3 LOGIC GATES</p>
<p>HDL Example 4.3 demonstrates bitwise operations acting on 4-bit busses for other basic logic functions.</p>
<p><br />A complete command such as assign y4 = ~(a &amp; b); is called a statement.<br />assign out = in1 op in2; is called a continuous assignment statement.</p>
<ul>
<li><a href="HDL Example 4.3 LOGIC GATES\HDL Example 4.3 LOGIC GATES RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li>Implementation schematics</li>
<li><a href="HDL Example 4.3 LOGIC GATES\HDL Example 4.3 LOGIC GATES Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.3%20LOGIC%20GATES" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">&nbsp;module gates_sv
<p>(<br />input logic [3:0] a, b,<br />output logic [3:0] y1, y2, y3, y4, y5<br />);</p>
<p><br />/*five different two-input logic<br />gates acting on 4-bit busses */<br /> assign y1 = a &amp; b; // AND<br /> assign y2 = a | b; // OR<br /> assign y3 = a ^ b; // XOR<br /> assign y4 = ~(a &amp; b); // NAND<br /> assign y5 = ~(a |b); // NOR<br />endmodule</p>
</td>
<td style="width: 380px;">&nbsp;module gates_v&nbsp;
<p>(<br /> input [3:0] a, b,<br /> output [3:0] y1, y2, y3, y4, y5<br />);</p>
<p><br />/* Five different two-input logic<br />gates acting on 4 bit busses */<br />assign y1 = a &amp; b; // AND<br />assign y2 = a | b; // OR<br />assign y3 = a ^ b; // XOR<br />assign y4 = ~(a &amp; b); // NAND<br />assign y5 = ~(a | b); // NOR<br />endmodule</p>
</td>
<td style="width: 380px;">
<p>&nbsp;library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity gates_vhd is<br />port<br />(<br />a, b: in STD_LOGIC_VECTOR(3 downto 0);<br />y1, y2, y3, y4, y5: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p><br />architecture synth of gates_vhd is<br />begin<br />-- five different two-input logic gates<br />-- acting on 4-bit busses<br /> y1 &lt;= a and b;<br /> y2 &lt;= a or b;<br /> y3 &lt;= a xor b;<br /> y4 &lt;= a nand b;<br /> y5 &lt;= a nor b;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>HDL Example 4.4 EIGHT-INPUT AND</p>
<p>As one would expect, |, ^, ~&amp;, and ~ | reduction operators are available for OR, XOR, NAND, and NOR as well.<br />Recall that a multi-input XOR performs parity, returning TRUE if an odd number of inputs are TRUE.</p>
<p>&nbsp;</p>
<ul>
<li><span style="color: #ff6600;"><a style="color: #ff6600;" href="HDL Example 4.4 EIGHT-INPUT AND\HDL Example 4.4 EIGHT-INPUT AND RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></span></li>
<li><span style="color: #ff6600;"><a style="color: #ff6600;" href="HDL%20Example 4.4 EIGHT-INPUT AND\HDL Example 4.4 EIGHT-INPUT AND RTL add Y1.PNG" target="_blank" rel="noopener">RTL schematics&nbsp;with y1 (SV)</a></span></li>
<li>Synthesis schematics</li>
<li><a href="HDL%20Example 4.4 EIGHT-INPUT AND\HDL Example 4.4 EIGHT-INPUT AND Implementation Schematic.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><span style="color: #ff6600;"><a style="color: #ff6600;" href="HDL%20Example 4.4 EIGHT-INPUT AND\HDL Example 4.4 EIGHT-INPUT AND Implementation Schematic add Y1.PNG" target="_blank" rel="noopener">Implementation schematics with y1 (SV)</a></span></li>
<li><a href="HDL Example 4.4 EIGHT-INPUT AND\HDL Example 4.4 EIGHT-INPUT AND Simulation add Y1.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.4%20EIGHT-INPUT%20AND" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">
<p>module and8_sv<br />(<br />input logic [7:0] a,<br />output logic y, y1<br />);</p>
<p>assign y = &amp;a;<br />// &amp;a is much easier to write than<br /> assign y1 = a[7] &amp; a[6] &amp; a[5] &amp; a[4] &amp; a[3] &amp; a[2] &amp; a[1] &amp; a[0];<br />endmodule</p>
<p>&nbsp;</p>
</td>
<td style="width: 380px;">module and8_v <br />(<br />input [7:0] a,<br />output y<br />);<br />assign y = &amp;a;<br />// &amp;a is much easier to write than<br />// assign y a[7] &amp; a[6] &amp; a[5] &amp; a[4] &amp;<br />// a[3] &amp; a[2] &amp; a[1] &amp; a[0];<br />endmodule
<p>&nbsp;</p>
</td>
<td style="width: 380px;">
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity and8_vhd is<br />port<br />(<br /> a: in STD_LOGIC_VECTOR(7 downto 0);<br /> y: out STD_LOGIC<br />);<br />end;</p>
<p><br />architecture synth of and8_vhd is<br />begin<br />y &lt;= a(7) and a(6) and a(5) and a(4) and a(3) and a(2) and a(1) and a(0);<br />end;&nbsp;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.5 2to1 MULTIPLEXER</p>
<p>HDL Example 4.5 illustrates a 2:1 multiplexer using a conditional assignment.<br />Conditional assignments select the output from among alternatives based on an input called the condition.</p>
<ul>
<li><a href="HDL Example 4.5 2to1 MULTIPLEXER\HDL Example 4.5 2to1 MULTIPLEXER RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li><a href="HDL%20Example 4.5 2to1 MULTIPLEXER\HDL Example 4.5 2to1 MULTIPLEXER implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.5 2to1 MULTIPLEXER\HDL Example 4.5 2to1 MULTIPLEXER Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.5%202to1%20MULTIPLEXER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">module mux2_sv<br />(<br />input logic [3:0] d0, d1,<br />input logic s,<br />output logic [3:0] y<br />);<br />assign y = s ? d1 : d0;<br />endmodule</td>
<td style="width: 380px;">&nbsp;module mux2_v <br />(<br />input [3:0] d0, d1,<br />input s,<br />output [3:0] y<br />);<br />assign y = s ? d1 : d0;<br />endmodule</td>
<td style="width: 380px;">&nbsp;library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity mux2_vhd is<br />port<br />(<br />d0, d1: in STD_LOGIC_VECTOR(3 downto 0);<br />s: in STD_LOGIC;<br />y: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;<br />architecture synth of mux2_vhd is<br />begin<br />y &lt;= d1 when s = '0' else d0;<br />end;</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.6 4to1 MULTIPLEXER</p>
<p>The multiplexer has multiple data (d) and one-hot enable (e) inputs. When one of the enables is asserted, the associated data is passed to the output.</p>
<ul>
<li><a href="HDL Example 4.6 4to1 MULTIPLEXER\HDL Example 4.6 4to1 MULTIPLEXER RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="HDL%20Example 4.6 4to1 MULTIPLEXER\HDL Example 4.6 4to1 MULTIPLEXER Implementation SV.PNG" target="_blank" rel="noopener">Implementation schematics&nbsp;SV</a></li>
<li><a href="HDL%20Example 4.6 4to1 MULTIPLEXER\HDL Example 4.6 4to1 MULTIPLEXER Implementation V.PNG" target="_blank" rel="noopener">Implementation schematics&nbsp;V</a></li>
<li><a href="HDL Example 4.6 4to1 MULTIPLEXER\HDL Example 4.6 4to1 MULTIPLEXER Implementation VHDL.PNG" target="_blank" rel="noopener">Implementation schematics VHDL</a></li>
<li><a href="HDL Example 4.6 4to1 MULTIPLEXER\HDL Example 4.6 4to1 MULTIPLEXER Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.6%204to1%20MULTIPLEXER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">
<p>&nbsp;module mux4_sv<br />(<br />input logic [3:0] d0, d1, d2, d3,<br />input logic [1:0] s,<br />output logic [3:0] y<br />);<br />assign y = s[1] ? (s[0] ? d3 : d2): (s[0] ? d1 : d0);<br />endmodule</p>
</td>
<td style="width: 380px;">&nbsp;module mux4_v<br />(<br />input [3:0] d0, d1, d2, d3,<br />input [1:0] s,<br />output [3:0] y<br />);<br />assign y = s[1] ? (s[0] ? d3 : d2) : (s[0] ? d1 : d0);<br />endmodule</td>
<td style="width: 380px;">
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity mux4_vhd is<br />port(<br />d0, d1,d2, d3: in STD_LOGIC_VECTOR(3 downto 0);<br />s: in STD_LOGIC_VECTOR(1 downto 0);<br />y: out STD_LOGIC_VECTOR(3 downto 0)--;<br />--y_1: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p><br />architecture synth1 of mux4_vhd is<br />begin<br />y &lt;= d0 when s = "00" <br />else d1 when s = "01" <br />else d2 when s = "10" <br />else d3;</p>
<p>-- next code make uncorrect RTL and Synthesis<br />--with s select y_1 &lt;=<br />-- d0 when "00",<br />-- d1 when "01",<br />-- d2 when "10",<br />-- d3 when others;<br /> <br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.7 FULL ADDER</p>
<p>P and G are called internal variables, because they are neither inputs nor outputs but are used only internal to the module. They are similar to local variables in programming languages.</p>
<ul>
<li><a href="HDL Example 4.7 FULL ADDER\HDL Example 4.7 FULL ADDER RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li><a href="HDL Example 4.7 FULL ADDER\HDL Example 4.7 FULL ADDER implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.7 FULL ADDER\HDL Example 4.7 FULL ADDER Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.7%20FULL%20ADDER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">
<p>module fulladder_sv<br />(<br />input logic a, b, cin,<br />output logic s, cout<br />);</p>
<p><br />logic p, g;</p>
<p><br />assign p = a ^ b;<br />assign g = a &amp; b;<br />assign s = p ^ cin;<br />assign cout = g |(p &amp; cin);<br />endmodule</p>
</td>
<td style="width: 380px;">
<p>module fulladder_v<br />(<br />input a, b, cin,<br />output s, cout<br />);</p>
<p><br />wire p, g;</p>
<p><br />assign p = a ^ b;<br />assign g = a &amp; b;<br />assign s = p ^ cin;<br />assign cout = g | (p &amp; cin);<br />endmodule</p>
</td>
<td style="width: 380px;">
<p>&nbsp;library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity fulladder_vhd is<br />port<br />(<br />a, b, cin: in STD_LOGIC;<br />s, cout: out STD_LOGIC<br />);<br />end;</p>
<p><br />architecture synth of fulladder_vhd is</p>
<p><br />signal p, g: STD_LOGIC;</p>
<p><br />begin<br />p &lt;= a xor b;<br />g &lt;= a and b;<br />s &lt;= p xor cin;<br />cout &lt;= g or (p and cin);<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>HDL Example 4.10 TRISTATE BUFFER</p>
<p>&nbsp;HDLs use x to indicate an invalid logic level. If a bus is simultaneously driven to 0 and 1 by two enabled tristate buffers (or other gates), the result is x, indicating contention. If all the tristate buffers driving a bus are simultaneously OFF, the bus will float, indicated by z.<br /><br /></p>
<ul>
<li><a href="HDL Example 4.10 TRISTATE BUFFER\HDL Example 4.10 TRISTATE BUFFER RTL.PNG.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li><a href="HDL Example 4.10 TRISTATE BUFFER\HDL Example 4.10 TRISTATE BUFFER Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.10 TRISTATE BUFFER\HDL Example 4.10 TRISTATE BUFFER Simulation Full.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="HDL%20Example 4.10 TRISTATE BUFFER\HDL Example 4.10 TRISTATE BUFFER Simulation 1.PNG" target="_blank" rel="noopener">Simulations waveforms&nbsp;Zoom</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.10%20TRISTATE%20BUFFER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">&nbsp;module tristate_sv<br />(<br />input logic [3:0] a,<br />input logic en,<br />output tri [3:0] y<br />);<br />assign y = en ? a : 4'bz;<br />endmodule</td>
<td style="width: 380px;">&nbsp;module tristate_v <br />(<br />input [3:0] a,<br />input en,<br />output [3:0] y<br />);<br />assign y = en ? a : 4'bz;<br />endmodule</td>
<td style="width: 380px;">
<p>&nbsp;library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity tristate_vhd is<br />port<br />(<br />a: in STD_LOGIC_VECTOR(3 downto 0);<br />en: in STD_LOGIC;<br />y: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p><br />architecture synth of tristate_vhd is<br />begin<br />y &lt;= a when en = '1' else "ZZZZ";<br />--y &lt;= "ZZZZ" when en = '0' else a;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.12 BIT SWIZZLING</p>
<p>Often it is necessary to operate on a subset of a bus or to concatenate (join together) signals to form busses. These operations are collectively known as bit swizzling.</p>
<ul>
<li><a href="HDL Example 4.12 BIT SWIZZLING\HDL Example 4.12 BIT SWIZZLING RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li><a href="HDL Example 4.12 BIT SWIZZLING\HDL Example 4.12 BIT SWIZZLING Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.12 BIT SWIZZLING\HDL Example 4.12 BIT SWIZZLING Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.12%20BIT%20SWIZZLING" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">&nbsp;
<p>//HDL Example 4.12 BIT SWIZZLING</p>
<p>module BIT_SWIZZLING_sv <br />(<br /> input logic [4:0] C,<br /> input logic [4:0] D,<br /> output logic [8:0] Y<br />);</p>
<p>assign Y = {C[2:1], {3{D[0]}}, C[0], 3'b101}; //y = c2c1d0d0d0c0101 3'b101 - constant</p>
<p>endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>//HDL Example 4.12 BIT SWIZZLING</p>
<p>module BIT_SWIZZLING_v <br />(<br /> input [4:0] C,<br /> input [4:0] D,<br /> output [8:0] Y<br />);</p>
<p>assign Y = {C[2:1], {3{D[0]}}, C[0], 3'b101}; //y = c2c1d0d0d0c0101 3'b101 - constant</p>
<p>endmodule</p>
</td>
<td style="width: 380px;">
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity BIT_SWIZZLING_vhd is<br />port<br />(<br />C: in STD_LOGIC_VECTOR(4 downto 0);<br />D: in STD_LOGIC_VECTOR(4 downto 0);<br />Y: out STD_LOGIC_VECTOR(8 downto 0)<br />);<br />end;</p>
<p><br />architecture synth of BIT_SWIZZLING_vhd is<br />begin<br />Y &lt;= C(2 downto 1) &amp; D(0) &amp; D(0) &amp; D(0) &amp; C(0) &amp; "101";<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER</p>
<p>HDL Example 4.14 shows how to assemble a 4:1 multiplexer from three 2:1 multiplexers. Each copy of the 2:1 multiplexer is called an instance. Multiple instances of the same module are distinguished by distinct names, in this case lowmux, highmux, and finalmux.<br />This is an example of regularity, in which the 2:1 multiplexer is reused many times.</p>
<ul>
<li><a href="HDL Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER\HDL Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="HDL%20Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER\HDL Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER Synthesis.PNG" target="_blank" rel="noopener">Synthesis schematics All</a></li>
<li><a href="HDL%20Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER\HDL Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER Synthesis SV.PNG" target="_blank" rel="noopener">Synthesis schematics SV Zoom</a></li>
<li><a href="HDL%20Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER\HDL Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER Synthesis V.PNG" target="_blank" rel="noopener">Synthesis schematics V Zoom</a></li>
<li><a href="HDL Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER\HDL Example 4.14 STRUCTURAL MODEL OF 4to1 MULTIPLEXER Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.14%20STRUCTURAL%20MODEL%20OF%204to1%20MULTIPLEXER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">&nbsp;
<p>module mux4_sv<br />(<br />input logic [3:0] d0, d1, d2, d3,<br />input logic [1:0] s,<br />output logic [3:0] y<br />);</p>
<p>logic [3:0] low, high;</p>
<p>mux2_sv lowmux(d0, d1, s[0], low);<br />mux2_sv highmux(d2, d3, s[0], high);<br />mux2_sv finalmux(low, high, s[1], y);</p>
<p>endmodule</p>
<p>---------------------------------------------------------</p>
<p>module mux2_sv<br /> (<br /> input [3:0] d0,<br /> input [3:0] d1,<br /> input s,<br /> output [3:0] y<br /> );<br /> assign y = s ? d1 : d0;<br />endmodule</p>
<p>&nbsp;</p>
</td>
<td style="width: 380px;">
<p>&nbsp;module mux4_v<br />(<br />input [3:0] d0, d1, d2, d3,<br />input [1:0] s,<br />output [3:0] y<br />);</p>
<p>wire [3:0] low, high;</p>
<p>mux2_v lowmux (d0, d1, s[0], low);<br />mux2_v highmux (d2, d3, s[0], high);<br />mux2_v finalmux (low, high, s[1], y);</p>
<p>endmodule</p>
<p>---------------------------------------------------------</p>
<p>module mux2_v<br /> (<br /> input [3:0] d0,<br /> input [3:0] d1,<br /> input s,<br /> output [3:0] y<br /> );<br /> assign y = s ? d1 : d0;<br />endmodule</p>
</td>
<td style="width: 380px;">
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity mux4_vhd is<br />port <br />(<br />d0, d1, d2, d3: in STD_LOGIC_VECTOR (3 downto 0);<br />s: in STD_LOGIC_VECTOR (1 downto 0);<br />y: out STD_LOGIC_VECTOR (3 downto 0)<br />);<br />end;</p>
<p>architecture struct of mux4_vhd is</p>
<p>component mux2_vhd<br />port <br />( <br />d0, d1 : in STD_LOGIC_VECTOR (3 downto 0);<br />s: in STD_LOGIC;<br />y: out STD_LOGIC_VECTOR (3 downto 0)<br />);<br />end component;</p>
<p>signal low, high: STD_LOGIC_VECTOR (3 downto 0);</p>
<p>begin</p>
<p>lowmux: mux2_vhd <br />port map (<br /> d0 =&gt; d0,<br /> d1 =&gt; d1, <br /> s =&gt; s(0),<br /> y =&gt; low<br />);<br />highmux: mux2_vhd port map (d2, d3, s(0), high);<br />finalmux: mux2_vhd port map (low, high, s(1), y);</p>
<p>end;</p>
<p>&nbsp;---------------------------------------------------------</p>
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity mux2_vhd is<br />port <br />(<br />d0: in STD_LOGIC_VECTOR (3 downto 0);<br />d1: in STD_LOGIC_VECTOR (3 downto 0);<br />s: in STD_LOGIC;<br />y: out STD_LOGIC_VECTOR (3 downto 0)<br />;<br />end;</p>
<p>architecture synth of mux2_vhd is<br />begin<br />y &lt;= d0 when s = '0' else d1;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.15 STRUCTURAL MODEL OF 2to1 MULTIPLEXER</p>
<p><span class="fontstyle0">The structural modeling to construct a 2:1<br />multiplexer from a pair of tristate buffers.</span></p>
<ul>
<li><a href="HDL Example 4.15 STRUCTURAL MODEL OF 2to1 MULTIPLEXER\HDL Example 4.15 STRUCTURAL MODEL OF 2to1 MULTIPLEXER RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li><a href="HDL Example 4.15 STRUCTURAL MODEL OF 2to1 MULTIPLEXER\HDL Example 4.15 STRUCTURAL MODEL OF 2to1 MULTIPLEXER Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.15 STRUCTURAL MODEL OF 2to1 MULTIPLEXER\HDL Example 4.15 STRUCTURAL MODEL OF 2to1 MULTIPLEXER Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.15%20STRUCTURAL%20MODEL%20OF%202to1%20MULTIPLEXER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">
<p>&nbsp;module mux2_sv<br />(<br />input logic [3:0] d0, d1,<br />input logic s,<br />output tri [3:0] y<br />);<br />tristate_sv t0(d0, ~s, y);<br />tristate_sv t1(d1, s, y);<br />endmodule</p>
<p>---------------------------------------------------------</p>
<p>&nbsp;module tristate_sv<br />(<br />input logic [3:0] a,<br />input logic en,<br />output tri [3:0] y<br />);<br />assign y = en ? a : 4'bz;<br />endmodule</p>
</td>
<td style="width: 380px;">
<p>&nbsp;</p>
<p>module mux2_v <br />(<br />input [3:0] d0, d1,<br />input s,<br />output [3:0] y<br />);</p>
<p>tristate_v t0 (d0, ~s, y);<br />tristate_v t1 (d1, s, y);<br />endmodule&nbsp;</p>
<p>---------------------------------------------------------</p>
<p>&nbsp;module tristate_v <br />(<br />input [3:0] a,<br />input en,<br />output [3:0] y<br />);<br />assign y = en ? a : 4'bz;<br />endmodule</p>
<p>&nbsp;</p>
</td>
<td style="width: 380px;">
<p>&nbsp;</p>
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;</p>
<p>entity mux2_vhd is<br />port<br />(<br /> d0, d1: in STD_LOGIC_VECTOR(3 downto 0);<br /> s: in STD_LOGIC;<br /> y: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p>architecture struct of mux2_vhd is</p>
<p>component tristate_vhd<br />port<br />(<br /> a: in STD_LOGIC_VECTOR(3 downto 0);<br /> en: in STD_LOGIC;<br /> y: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end component;</p>
<p>signal sbar: STD_LOGIC;</p>
<p>begin</p>
<p>sbar &lt;= not s;<br />t0: tristate_vhd port map(d0, sbar, y);<br />t1: tristate_vhd port map(d1, s, y);<br />end;&nbsp;</p>
<p>---------------------------------------------------------</p>
<p>&nbsp;library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity tristate_vhd is<br />port<br />(<br />a: in STD_LOGIC_VECTOR(3 downto 0);<br />en: in STD_LOGIC;<br />y: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;<br />architecture synth of tristate_vhd is<br />begin<br />y &lt;= a when en = '1' else "ZZZZ";<br />--y &lt;= "ZZZZ" when en = '0' else a;<br />end;</p>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">&nbsp;
<p>HDL Example 4.16 ACCESSING PARTS OF BUSSES</p>
<p><span class="fontstyle0">shows how modules can access part of a bus. An<br />8-bit wide 2:1 multiplexer is built using two of the 4-bit 2:1 multiplexers<br />already defined, operating on the low and high nibbles of the byte.<br />In general, complex systems are designed </span><span class="fontstyle2">hierarchically. </span><span class="fontstyle0">The overall<br />system is described structurally by instantiating its major components.<br />Each of these components is described structurally from its building<br />blocks, and so forth recursively until the pieces are simple enough to<br />describe behaviorally. It is good style to avoid (or at least to minimize)<br />mixing structural and behavioral descriptions within a single module.</span></p>
<ul>
<li><a href="HDL Example 4.16 ACCESSING PARTS OF BUSSES\HDL Example 4.16 ACCESSING PARTS OF BUSSES RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li><a href="HDL Example 4.16 ACCESSING PARTS OF BUSSES\HDL Example 4.16 ACCESSING PARTS OF BUSSES Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.16 ACCESSING PARTS OF BUSSES\HDL Example 4.16 ACCESSING PARTS OF BUSSES Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.16%20ACCESSING%20PARTS%20OF%20BUSSES" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">&nbsp;
<p>module mux2_8_sv<br />(<br />input logic [7:0] d0, d1,<br />input logic s,<br />output logic [7:0] y<br />);</p>
<p>mux2_sv lsbmux(d0[3:0], d1[3:0], s, y[3:0]);<br />mux2_sv msbmux(d0[7:4], d1[7:4], s, y[7:4]);</p>
<p>endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>module mux2_8_v <br />(<br />input [7:0] d0, d1,<br />input s,<br />output [7:0] y<br />);</p>
<p>mux2_v lsbmux (d0[3:0], d1[3:0], s, y[3:0]);<br />mux2_v msbmux (d0[7:4], d1[7:4], s, y[7:4]);</p>
<p>endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity mux2_8_vhd is<br />port<br />(<br /> d0, d1: in STD_LOGIC_VECTOR(7 downto 0);<br /> s: in STD_LOGIC;<br /> y: out STD_LOGIC_VECTOR(7 downto 0)<br />);<br />end;</p>
<p>architecture struct of mux2_8_vhd is</p>
<p>component mux2_vhd<br />port<br />(<br /> d0, d1: in STD_LOGIC_VECTOR(3 downto 0);<br /> s: in STD_LOGIC;<br /> y: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end component;</p>
<p>begin</p>
<p>lsbmux: mux2_vhd port map<br />(<br /> d0 =&gt; d0(3 downto 0), <br /> d1 =&gt; d1(3 downto 0),<br /> s =&gt; s, <br /> y =&gt; y(3 downto 0)<br />);</p>
<p>msbmux: mux2_vhd port map<br />(<br /> d0 =&gt; d0(7 downto 4), <br /> d1 =&gt; d1(7 downto 4),<br /> s =&gt; s, <br /> y =&gt; y(7 downto 4)<br />);</p>
<p>end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.17 REGISTER</p>
<p><span class="fontstyle0">The flip-flop includes only </span><span class="fontstyle2">clk </span><span class="fontstyle0">in the sensitive list. It remembers its old value of </span><span class="fontstyle2">q </span><span class="fontstyle0">until the next rising edge of the </span><span class="fontstyle2">clk</span><span class="fontstyle0">, even if&nbsp;</span><span class="fontstyle2">d </span><span class="fontstyle0">changes in the interim.<br />In contrast, Verilog continuous assignment statements (</span><span class="fontstyle2">assign</span><span class="fontstyle0">) and VHDL concurrent assignment statements (&lt;=</span><span class="fontstyle0">) are reevaluated any time any of the inputs on the right-hand side changes. Therefore, such code necessarily describes combinational logic.</span></p>
<ul>
<li><a href="HDL Example 4.17 REGISTER\HDL Example 4.17 REGISTER RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li>Synthesis schematics</li>
<li><a href="HDL Example 4.17 REGISTER\HDL Example 4.17 REGISTER Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.17 REGISTER\HDL Example 4.17 REGISTER Simulation fail.PNG" target="_blank" rel="noopener">Simulations waveforms Fail</a></li>
<li><a href="HDL Example 4.17 REGISTER\HDL Example 4.17 REGISTER Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.17%20REGISTER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">&nbsp;
<p>module flop_sv<br />(<br />input logic clk,<br />input logic [3:0] d,<br />output logic [3:0] q<br />);</p>
<p>always_ff @(posedge clk)<br />q &lt;= d;</p>
<p>endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>module flop_v<br />(<br />input clk,<br />input [3:0] d,<br />output reg [3:0] q<br />);</p>
<p>always @ (posedge clk)<br />q &lt;= d;</p>
<p>endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>library IEEE; <br />use IEEE.STD_LOGIC_1164.all;<br />entity flop_vhd is<br />port<br />(<br />clk: in STD_LOGIC;<br />d: in STD_LOGIC_VECTOR(3 downto 0);<br />q: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p>architecture synth of flop_vhd is</p>
<p>begin<br />process(clk) begin<br /> if rising_edge(clk) then<br />-- if clk'event and clk = '1' then<br /> q &lt;= d;<br />end if;<br />end process;</p>
<p>end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp; <span class="fontstyle0">HDL Example 4.18&nbsp;</span><span class="fontstyle2">RESETTABLE REGISTER</span></p>
<p>Generally, it is good practice to use resettable registers so that on powerup you can put your system in a known state. The reset may be either asynchronous or synchronous. Recall that asynchronous reset occurs immediately, whereas synchronous reset clears the output only on the next rising edge of the clock.</p>
<ul>
<li><a href="HDL Example 4.18 RESETTABLE REGISTER_Asyn_Syn\HDL Example 4.18 RESETTABLE REGISTER_Asyn_Syn_RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="HDL%20Example 4.18 RESETTABLE REGISTER_Asyn_Syn\HDL Example 4.18 RESETTABLE REGISTER_Asyn_Syn_Synthesis.PNG" target="_blank" rel="noopener">Synthesis schematics</a></li>
<li><a href="HDL Example 4.18 RESETTABLE REGISTER_Asyn_Syn\HDL Example 4.18 RESETTABLE REGISTER_Asyn_Syn_Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.18 RESETTABLE REGISTER_Asyn_Syn\HDL Example 4.18 RESETTABLE REGISTER_Asyn_Syn_Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.18%20RESETTABLE%20REGISTER_Asyn_Syn" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">
<p>&nbsp;module flop_ar_sv<br />(<br />input logic clk,<br />input logic reset,<br />input logic [3:0] d,<br />output logic [3:0] q<br />);<br />// asynchronous reset</p>
<p><br />always_ff @(posedge clk, posedge reset)<br />if (reset) <br /> q &lt;= 4'b0;<br />else <br /> q &lt;= d;<br />endmodule</p>
<p>---------------------------------------------------------</p>
<p>module flopr_sr_sv<br />(<br />input logic clk,<br />input logic reset,<br />input logic [3:0] d,<br />output logic [3:0] q<br />);<br />// synchronous reset<br />always_ff @(posedge clk)<br />if (reset) <br /> q &lt;= 4'b0;<br />else <br /> q &lt;= d;<br />endmodule</p>
</td>
<td style="width: 380px;">
<p>&nbsp;</p>
<p>module flop_ar_v<br />(<br />input clk,<br />input reset,<br />input [3:0] d,<br />output reg [3:0] q<br />);<br />// asynchronous reset</p>
<p><br />always @ (posedge clk, posedge reset)<br />if (reset) <br /> q &lt;= 4'b0;<br />else <br /> q &lt;= d;<br />endmodule</p>
<p>---------------------------------------------------------</p>
<p>module flopr_sr_v <br />(<br />input clk,<br />input reset,<br />input [3:0] d,<br />output reg [3:0] q<br />);<br />// synchronous reset<br />always @ (posedge clk)<br />if (reset) <br /> q &lt;= 4'b0;<br />else <br /> q &lt;= d;<br />endmodule</p>
<p>&nbsp;</p>
</td>
<td style="width: 380px;">
<p>&nbsp;</p>
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity flopr_as_vhd is</p>
<p>port<br />(<br />clk, reset: in STD_LOGIC;<br />d: in STD_LOGIC_VECTOR(3 downto 0);<br />q: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p>architecture asynchronous of flopr_as_vhd is</p>
<p>begin</p>
<p>process(clk, reset) begin<br />if reset = '1' then<br /> q &lt;= "0000";<br />elsif rising_edge(clk) then<br /> q &lt;= d;<br />end if;<br />end process;<br />end;</p>
<p>---------------------------------------------------------</p>
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity flopr_sr_vhd is</p>
<p>port<br />(<br /> clk, reset: in STD_LOGIC;<br /> d: in STD_LOGIC_VECTOR(3 downto 0);<br /> q: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p>architecture synchronous of flopr_sr_vhd is</p>
<p>begin</p>
<p>process(clk) begin<br />if rising_edge(clk) then<br />if reset = '1' then <br /> q &lt;= "0000";<br />else <br /> q &lt;= d;<br />end if;<br />end if;<br />end process;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.19 RESETTABLE ENABLED REGISTER</p>
<p><span class="fontstyle0">Enabled registers respond to the clock only when the enable is asserted.<br />It is retains its old value if both </span><span class="fontstyle2">reset </span><span class="fontstyle0">and </span><span class="fontstyle2">en </span><span class="fontstyle0">are FALSE.</span></p>
<ul>
<li><a href="HDL Example 4.19 RESETTABLE ENABLED REGISTER\HDL Example 4.19 RESETTABLE ENABLED REGISTER_RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="HDL Example 4.19 RESETTABLE ENABLED REGISTER\HDL Example 4.19 RESETTABLE ENABLED REGISTER_Synthesis.PNG" target="_blank" rel="noopener">Synthesis schematics</a></li>
<li><a href="HDL Example 4.19 RESETTABLE ENABLED REGISTER\HDL Example 4.19 RESETTABLE ENABLED REGISTER_Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.19 RESETTABLE ENABLED REGISTER\HDL Example 4.19 RESETTABLE ENABLED REGISTER_Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.19%20RESETTABLE%20ENABLED%20REGISTER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
<p>&nbsp;</p>
</td>
<td style="width: 380px;">
<p>&nbsp;module flopenr_sv<br />(<br />input logic clk,<br />input logic reset,<br />input logic en,<br />input logic [3:0] d,<br />output logic [3:0] q<br />);<br />// asynchronous reset<br />always_ff @(posedge clk, posedge reset)<br /> if (reset) q &lt;= 4'b0;<br /> else if (en) q &lt;= d;<br />endmodule</p>
</td>
<td style="width: 380px;">&nbsp;module flopenr_v<br />(<br />input clk,<br />input reset,<br />input en,<br />input [3:0] d,<br />output reg[3:0] q<br />);<br />// asynchronous reset<br />always @(posedge clk, posedge reset)<br /> if (reset) q &lt;= 4'b0;<br /> else if (en) q &lt;= d;<br />endmodule</td>
<td style="width: 380px;">&nbsp;
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity flopenr_vhd is<br />port<br />(<br /> clk, reset, en: in STD_LOGIC;<br /> d: in STD_LOGIC_VECTOR(3 downto 0);<br /> q: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p>architecture asynchronous of flopenr_vhd is<br />-- asynchronous reset<br />begin<br />process(clk, reset) begin<br /> if reset = '1' then<br /> q &lt;= "0000";<br /> elsif rising_edge(clk) then<br /> if en ='1' then<br /> q &lt;= d;<br /> end if;<br /> end if;<br />end process;<br />end;</p>
<p>&nbsp;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.20 SYNCHRONIZER</p>
<p>A single always/process statement can be used to describe multiple pieces of hardware. For example, consider the synchronizer made of two back-to-back flip-flops. On the rising edge of<br />clk, d is copied to n1. At the same time, n1 is copied to q.</p>
<ul>
<li><a href="HDL Example 4.20 SYNCHRONIZER\HDL Example 4.20 SYNCHRONIZER_RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="HDL Example 4.20 SYNCHRONIZER\HDL Example 4.20 SYNCHRONIZER_synthesis.PNG" target="_blank" rel="noopener">Synthesis schematics</a></li>
<li><a href="HDL Example 4.20 SYNCHRONIZER\HDL Example 4.20 SYNCHRONIZER_implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.20 SYNCHRONIZER\HDL Example 4.20 SYNCHRONIZER_Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.20%20SYNCHRONIZER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">
<p>module sync_sv<br />(<br />input logic clk,<br />input logic d,<br />output logic q<br />);<br />logic n1;<br />always_ff @(posedge clk)<br />begin<br />n1 &lt;= d; // nonblocking<br />q &lt;= n1; // nonblocking<br />end<br />endmodule</p>
</td>
<td style="width: 380px;">
<p>module sync_v <br />(<br />input clk, <br />input d,<br />output reg q<br />);</p>
<p>reg n1;</p>
<p>always @ (posedge clk)<br />begin<br />n1 &lt;= d;<br />q &lt;= n1;<br />end<br />endmodule</p>
</td>
<td style="width: 380px;">library IEEE; <br />use IEEE.STD_LOGIC_1164.all;<br />library IEEE; <br />use IEEE.STD_LOGIC_1164.all;<br />entity sync_vhd is port <br />( <br />clk: in <br />STD_LOGIC; <br />d: in STD_LOGIC; <br />q: out STD_LOGIC <br />);<br />end;<br />architecture good of sync_vhd is<br />signal n1: STD_LOGIC;<br />begin process(clk) <br />begin <br />if rising_edge(clk) then <br />n1 &lt;= d; <br />q &lt;= n1; <br />end if; <br />end process;<br />end;</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.21 Latches Do not do that</p>
<p>A D latch is transparent when the clock is HIGH, allowing data to flow from input to output. The latch becomes opaque when the clock is LOW, retaining its old state. HDL Example 4.22 shows the idiom for a D latch.<br />Not all synthesis tools support latches well. Unless you know that your tool does support latches and you have a good reason to use them, avoid them, and use edge-triggered flip-flops instead. Furthermore, take care that your HDL does not imply any unintended latches, something that is easy to do if you aren&rsquo;t attentive. Many synthesis tools warn you when a latch is created; if you didn&rsquo;t expect one, track down the bug in your HDL</p>
<ul>
<li><a href="VHDL_SV_Verilog\HDL Example 4.21 Latches Do not do that\Latches Do not do that RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="VHDL_SV_Verilog\HDL Example 4.21 Latches Do not do that\Latches Do not do that Synthesis.PNG" target="_blank" rel="noopener">Synthesis schematics</a></li>
<li><a href="VHDL_SV_Verilog\HDL Example 4.21 Latches Do not do that\Latches Do not do that Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="VHDL_SV_Verilog\HDL Example 4.21 Latches Do not do that\Latches Do not do that Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.21%20Latches%20Do%20not%20do%20that" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
<p>&nbsp;</p>
</td>
<td style="width: 380px;">&nbsp;
<p>module latch_sv<br />(<br />input logic clk,<br />input logic [3:0] d,<br />output logic [3:0] q<br />);</p>
<p>always_latch // it is similar to always @(clk, d)<br />if (clk) q &lt;= d;<br />endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>module latch_v <br />(<br />input clk,<br />input [3:0] d,<br />output reg [3:0] q<br />);</p>
<p>always @ (clk, d)<br />if (clk) q &lt;= d;<br />endmodule</p>
</td>
<td style="width: 380px;">
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;</p>
<p>entity latch_vhd is<br />port<br />(<br />clk: in STD_LOGIC;<br />d: in STD_LOGIC_VECTOR(3 downto 0);<br />q: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p>architecture synth of latch_vhd is<br />begin<br />process(clk, d) <br />begin<br />if clk = '1' then<br />q &lt;= d;<br />end if;<br />end process;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;HDL Example 4.22 INVERTER USING always_process</p>
<p>&nbsp;However, always/process statements can also be used to describe combinational logic behaviorally if the sensitivity list is written to respond to changes in all of the inputs and the body prescribes the output value for every possible input combination. HDL Example 4.22 uses always/process statements to describe a bank of four inverters.</p>
<ul>
<li><a href="HDL Example 4.22 INVERTER USING always_process\HDL Example 4.22 INVERTER USING always_process_RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="HDL Example 4.22 INVERTER USING always_process\HDL Example 4.22 INVERTER USING always_process_Synthesis.PNG" target="_blank" rel="noopener">Synthesis schematics</a></li>
<li><a href="HDL Example 4.22 INVERTER USING always_process\HDL Example 4.22 INVERTER USING always_process_Synthesis.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.22 INVERTER USING always_process\HDL Example 4.22 INVERTER USING always_process_Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.22%20INVERTER%20USING%20always_process" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
<p>The example is poor applications of always/process statements for modeling combinational logic because they require more lines than the equivalent approach with assignment statements. Moreover, they pose the risk of inadvertently implying sequential logic if the inputs are left out of the sensitivity list. However, case and if statements are convenient for modeling more complicated combinational logic. case and if statements must appear within always/process statements and are examined in the next sections.</p>
</td>
<td style="width: 380px;">
<p>module inv_sv<br />(<br />input logic [3:0] a,<br />output logic[3:0] y<br />);</p>
<p>always_comb<br />y = ~a;<br />endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>module inv_v <br />(<br />input [3:0] a,<br />output reg [3:0] y<br />);</p>
<p>always @ (*)<br />y = ~a;</p>
<p>endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity inv_vhd is<br />port<br />(<br />a: in STD_LOGIC_VECTOR(3 downto 0);<br />y: out STD_LOGIC_VECTOR(3 downto 0)<br />);<br />end;</p>
<p>architecture proc of inv_vhd is</p>
<p>begin<br />--process(all) begin -- supported in VHDL 1076-2008<br />process (a) begin<br />y &lt;= not a;<br />end process;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>&nbsp;</p>
<p>HDL Example 4.23 FULL ADDER USING always_process</p>
<p><span class="fontstyle0">Full adder using intermediate signals<br /></span><span class="fontstyle2">p </span><span class="fontstyle0">and </span><span class="fontstyle2">g </span><span class="fontstyle0">to compute </span><span class="fontstyle2">s </span><span class="fontstyle0">and </span><span class="fontstyle2">cout</span><span class="fontstyle0">. It produces the same circuit from<br />Figure 4.8, but uses </span><span class="fontstyle2">always/process </span><span class="fontstyle0">statements in place of assignment<br />statements.</span></p>
<ul>
<li><a href="HDL Example 4.23 FULL ADDER USING always_process\HDL Example 4.23 FULL ADDER USING always_process_RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="HDL Example 4.23 FULL ADDER USING always_process\HDL Example 4.23 FULL ADDER USING always_process_Synthesis.PNG" target="_blank" rel="noopener">Synthesis schematics</a></li>
<li><a href="HDL Example 4.23 FULL ADDER USING always_process\HDL Example 4.23 FULL ADDER USING always_process_Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.23 FULL ADDER USING always_process\HDL Example 4.23 FULL ADDER USING always_process_Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.23%20FULL%20ADDER%20USING%20always_process" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
<p>The example is poor applications of always/process statements for modeling combinational logic because they require more lines than the equivalent approach with assignment statements. Moreover, they pose the risk of inadvertently implying sequential logic if the inputs are left out of the sensitivity list. However, case and if statements are convenient for modeling more complicated combinational logic. case and if statements must appear within always/process statements and are examined in the next sections.</p>
</td>
<td style="width: 380px;">&nbsp;
<p>module fulladder_sv<br />(<br />input logic a, b, cin,<br />output logic s, cout<br />);</p>
<p>logic p, g;</p>
<p>always_comb<br />begin<br />p = a ^ b; // blocking<br />g = a &amp; b; // blocking<br />s = p ^ cin; // blocking<br />cout = g |(p &amp; cin); // blocking<br />end<br />endmodule</p>
<p>&nbsp;</p>
</td>
<td style="width: 380px;">module fulladder_v<br />(<br />input a, b, cin,<br />output reg s, cout<br />);<br />reg p, g;<br />always @ (*)<br />begin<br />p = a ^ b;// blocking<br />g = a &amp; b;// blocking<br />s = p ^ cin;// blocking<br />cout = g | (p &amp; cin);// blocking<br />end<br />endmodule</td>
<td style="width: 380px;">&nbsp;
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity fulladder_vhd is</p>
<p>port<br />(<br />a, b, cin: in STD_LOGIC;<br />s, cout: out STD_LOGIC<br />);<br />end;</p>
<p>architecture synth of fulladder_vhd is<br />begin<br />process(all) -- supported in VHDL 1076-2008<br />--process (a, b, cin)<br />variable p, g: STD_LOGIC;<br />begin<br />p := a xor b; -- blocking<br />g := a and b; -- blocking<br />s &lt;= p xor cin;<br />cout &lt;= g or (p and cin);<br />end process;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">
<p>HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER</p>
<p>A better application of using the always/process statement for combinational logic is a seven-segment display decoder that takes advantage of the case statement that must appear inside an always/process statement.<br />The case statement performs different actions depending on the value of its input. A case statement implies combinational logic if all possible input combinations are defined; otherwise, it implies sequential logic, because the output will keep its old value in the undefined cases.</p>
<ul>
<li><a href="HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER\HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER_RTL.PNG" target="_blank" rel="noopener">RTL schematics</a></li>
<li><a href="HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER\HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER_Synthesis.PNG" target="_blank" rel="noopener">Synthesis schematics</a></li>
<li><a href="HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER\HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER_Implementation.PNG" target="_blank" rel="noopener">Implementation schematics</a></li>
<li><a href="HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER\HDL Example 4.24 SEVEN-SEGMENT DISPLAY DECODER_Simulation.PNG" target="_blank" rel="noopener">Simulations waveforms</a></li>
<li><a href="https://github.com/SystemVerilog-VHDL-Verilog/VHDL_SV_Verilog/tree/master/HDL%20Example%204.24%20SEVEN-SEGMENT%20DISPLAY%20DECODER" target="_blank" rel="noopener">Vivado Project</a></li>
</ul>
</td>
<td style="width: 380px;">&nbsp;
<p>module sevenseg_sv<br />(<br />input logic [3:0] data,<br />output logic [6:0] segments<br />);</p>
<p>always_comb<br />case(data)<br />// abc_defg<br />0: segments = 7'b111_1110;<br />1: segments = 7'b011_0000;<br />2: segments = 7'b110_1101;<br />3: segments = 7'b111_1001;<br />4: segments = 7'b011_0011;<br />5: segments = 7'b101_1011;<br />6: segments = 7'b101_1111;<br />7: segments = 7'b111_0000;<br />8: segments = 7'b111_1111;<br />9: segments = 7'b111_0011;<br />default: segments = 7'b000_0000;<br />endcase<br />endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>module sevenseg_v <br />(<br />input [3:0] data,<br />output reg [6:0] segments<br />);</p>
<p>always @ (*)<br />case (data)<br />// abc_defg<br />0: segments = 7'b111_1110;<br />1: segments = 7'b011_0000;<br />2: segments = 7'b110_1101;<br />3: segments = 7'b111_1001;<br />4: segments = 7'b011_0011;<br />5: segments = 7'b101_1011;<br />6: segments = 7'b101_1111;<br />7: segments = 7'b111_0000;<br />8: segments = 7'b111_1111;<br />9: segments = 7'b111_1011;<br />default: segments = 7'b000_0000;<br />endcase<br />endmodule</p>
</td>
<td style="width: 380px;">&nbsp;
<p>library IEEE; use IEEE.STD_LOGIC_1164.all;<br />entity sevenseg_vhd is<br />port<br />(<br />data: in STD_LOGIC_VECTOR(3 downto 0);<br />segments: out STD_LOGIC_VECTOR(6 downto 0)<br />);<br />end;</p>
<p>architecture synth of sevenseg_vhd is<br />begin<br />process(all) begin --(VHDL 2008)<br />case data is<br />-- abcdefg<br />when X"0" =&gt; segments &lt;= "1111110";<br />when X"1" =&gt; segments &lt;= "0110000";<br />when X"2" =&gt; segments &lt;= "1101101";<br />when X"3" =&gt; segments &lt;= "1111001";<br />when X"4" =&gt; segments &lt;= "0110011";<br />when X"5" =&gt; segments &lt;= "1011011";<br />when X"6" =&gt; segments &lt;= "1011111";<br />when X"7" =&gt; segments &lt;= "1110000";<br />when X"8" =&gt; segments &lt;= "1111111";<br />when X"9" =&gt; segments &lt;= "1110011";<br />when others =&gt; segments &lt;= "0000000";<br />end case;<br />end process;<br />end;</p>
</td>
</tr>
<tr>
<td style="width: 300px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
</tr>
<tr>
<td style="width: 300px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
</tr>
<tr>
<td style="width: 300px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
<td style="width: 380px;">&nbsp;</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>